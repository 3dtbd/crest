// Crest Ocean System

// This file is subject to the MIT License as seen in the root of this folder structure (LICENSE)

#pragma kernel ShapeCombine
#pragma kernel ShapeCombine_DISABLE_COMBINE _DISABLE_COMBINE
#pragma kernel ShapeCombine_FLOW_ON _FLOW_ON
#pragma kernel ShapeCombine_FLOW_ON_DISABLE_COMBINE _FLOW_ON _DISABLE_COMBINE
#pragma kernel ShapeCombine_DYNAMIC_WAVE_SIM_ON _DYNAMIC_WAVE_SIM_ON
#pragma kernel ShapeCombine_DYNAMIC_WAVE_SIM_ON_DISABLE_COMBINE _DYNAMIC_WAVE_SIM_ON _DISABLE_COMBINE
#pragma kernel ShapeCombine_FLOW_ON_DYNAMIC_WAVE_SIM_ON _FLOW_ON _DYNAMIC_WAVE_SIM_ON
#pragma kernel ShapeCombine_FLOW_ON_DYNAMIC_WAVE_SIM_ON_DISABLE_COMBINE _FLOW_ON _DYNAMIC_WAVE_SIM_ON _DISABLE_COMBINE

#include "../OceanLODData.hlsl"

float _HorizDisplace;
float _DisplaceClamp;
float _CrestTime;

#pragma enable_d3d11_debug_symbols


Texture2DArray _LD_TexArray_WaveBuffer;

#if WORKAROUND_UAV_LIMITATION
RWTexture2DArray<uint> _LD_TexArray_AnimatedWaves_Compute;
#else
RWTexture2DArray<float4> _LD_TexArray_AnimatedWaves_Compute;
#endif

void Flow(out float2 offsets, out float2 weights)
{
	const float period = 3.0 * _LD_Params[_LD_SliceIndex].x;
	const float half_period = period / 2.0;
	offsets = fmod(float2(_CrestTime, _CrestTime + half_period), period);
	weights.x = offsets.x / half_period;
	if (weights.x > 1.0) weights.x = 2.0 - weights.x;
	weights.y = 1.0 - weights.x;
}

// Sampling functions
void SampleDisplacementWaveBuffer(in float3 i_uv_slice, in float i_wt, inout float3 io_worldPos, inout float io_sss)
{
	const half4 data = _LD_TexArray_WaveBuffer.SampleLevel(LODData_linear_clamp_sampler, i_uv_slice, 0.0);
	io_worldPos += i_wt * data.xyz;
	io_sss += i_wt * data.a;
}

// f.x in lower bits, f.y in upper bits
half2 uintToHalf2(uint i)
{
	return half2(f16tof32(i), f16tof32(i >> 16));
}

uint half2ToUint(half2 f)
{
	return (f32tof16(f.y) << 16) + f32tof16(f.x);
}


half4 SampleAnimatedWavesCompute(in uint3 coords)
{
#if WORKAROUND_UAV_LIMITATION
	uint w, h, d;
	_LD_TexArray_AnimatedWaves_Compute.GetDimensions(w, h, d);

	uint3 numLods = uint3(0, 0, d / 2);
	half4 data;
	data.xy = uintToHalf2(_LD_TexArray_AnimatedWaves_Compute[coords]);
	data.zw = uintToHalf2(_LD_TexArray_AnimatedWaves_Compute[coords + numLods]);
	return data;
#else
	return _LD_TexArray_AnimatedWaves_Compute[coords];
#endif
}

void SetValueAnimatedWavesCompute(in uint3 coords, in half4 value)
{
#if WORKAROUND_UAV_LIMITATION
	uint w, h, d;
	_LD_TexArray_AnimatedWaves_Compute.GetDimensions(w, h, d);

	uint3 numLods = uint3(0, 0, d / 2);
	_LD_TexArray_AnimatedWaves_Compute[coords] = half2ToUint(value.xy);
	_LD_TexArray_AnimatedWaves_Compute[coords + numLods] = half2ToUint(value.zw);
#else
	_LD_TexArray_AnimatedWaves_Compute[coords] = value;
#endif
}


void SampleDisplacementAnimatedWavesCompute(
	in float i_width, in float i_height, in float3 i_uv_slice,
	in float i_wt, inout float3 io_worldPos, inout float io_sss
) {
	// NOTE: We have to roll our own bilinear filter in Compute shaders when
	// reading from a RWTexture. The documentation below explains how SRV
	// and UAV mappings of the same texture cannot exist at the same time.
	// https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sm5-object-rwtexture2d

	// Convert from UV to coordinates
	const float2 pixelCoord = i_uv_slice.xy * float2(i_width, i_height);

	// Make relative to pixel centers
	float2 pixelCoordCenters = pixelCoord - 0.5;

	// Clamp from below and above (desired?)
	pixelCoordCenters = clamp(pixelCoordCenters, 0.0, float2(i_width, i_height) - 1.0);

	// Compute integral and fractional parts
	const float2 pixelCoordCentersBotLeft = floor(pixelCoordCenters);
	const float2 pixelCoordCentersFrac = frac(pixelCoordCenters);

	const float4 dataBotLeft = SampleAnimatedWavesCompute(float3(pixelCoordCentersBotLeft, i_uv_slice.z));
	const float4 dataBotRight = SampleAnimatedWavesCompute(float3(pixelCoordCentersBotLeft + float2(1.0, 0.0), i_uv_slice.z));
	const float4 dataTopLeft = SampleAnimatedWavesCompute(float3(pixelCoordCentersBotLeft + float2(0.0, 1.0), i_uv_slice.z));
	const float4 dataTopRight = SampleAnimatedWavesCompute(float3(pixelCoordCentersBotLeft + float2(1.0, 1.0), i_uv_slice.z));

	const float4 dataLerped = lerp(
		lerp(dataBotLeft, dataBotRight, pixelCoordCentersFrac.x),
		lerp(dataTopLeft, dataTopRight, pixelCoordCentersFrac.x),
		pixelCoordCentersFrac.y
	);

	io_worldPos += i_wt * dataLerped.xyz;
	io_sss += dataLerped.a;
}

void ShapeCombineBase(uint3 id)
{
	float width; float height; float depth;
	{
		_LD_TexArray_AnimatedWaves_Compute.GetDimensions(width, height, depth);
	}
	const float2 input_uv = IDtoUV(id.xy, width, height);

	const float2 worldPosXZ = UVToWorld(input_uv);

	// sample the shape 1 texture at this world pos
	const float3 uv_nextLod = WorldToUV_BiggerLod(worldPosXZ);

	float3 uv_thisLod = float3(input_uv, _LD_SliceIndex);

	float3 result = 0.0;
	half sss = 0.0;
	
#if _FLOW_ON
	float2 flow = 0.0;
	SampleFlow(_LD_TexArray_Flow, uv_thisLod, 1.0, flow);

	float2 offsets, weights;
	Flow(offsets, weights);

	float3 uv_thisLod_flow_0 = WorldToUV(worldPosXZ - offsets[0] * flow);
	float3 uv_thisLod_flow_1 = WorldToUV(worldPosXZ - offsets[1] * flow);
	SampleDisplacementWaveBuffer(uv_thisLod_flow_0, weights[0], result, sss);
	SampleDisplacementWaveBuffer(uv_thisLod_flow_1, weights[1], result, sss);
#else
	float4 data = _LD_TexArray_WaveBuffer.SampleLevel(LODData_linear_clamp_sampler, uv_thisLod, 0.0);
	result += data.xyz;
	sss = data.a;
#endif

	// C# Script determines whether this enabled or not by selecting appropriate
	// kernel for each LOD.
#if !_DISABLE_COMBINE
	SampleDisplacementAnimatedWavesCompute(width, height, uv_nextLod, 1.0, result, sss);
#endif

#if _DYNAMIC_WAVE_SIM_ON
	{
		// convert dynamic wave sim to displacements

		half waveSimY = SampleLod(_LD_TexArray_DynamicWaves, uv_thisLod).x;
		result.y += waveSimY;

		const float2 invRes = float2(_LD_Params[_LD_SliceIndex].w, 0.0);
		const half waveSimY_px = SampleLod(_LD_TexArray_DynamicWaves, uv_thisLod + float3(invRes.xy, 0)).x;
		const half waveSimY_nx = SampleLod(_LD_TexArray_DynamicWaves, uv_thisLod - float3(invRes.xy, 0)).x;
		const half waveSimY_pz = SampleLod(_LD_TexArray_DynamicWaves, uv_thisLod + float3(invRes.yx, 0)).x;
		const half waveSimY_nz = SampleLod(_LD_TexArray_DynamicWaves, uv_thisLod - float3(invRes.yx, 0)).x;
		// compute displacement from gradient of water surface - discussed in issue #18 and then in issue #47

		// For gerstner waves, horiz displacement is proportional to derivative of vertical displacement multiplied by the wavelength
		const float wavelength_mid = 2.0 * _LD_Params[_LD_SliceIndex].x * 1.5;
		const float wavevector = 2.0 * 3.14159 / wavelength_mid;
		const float2 dydx = (float2(waveSimY_px, waveSimY_pz) - float2(waveSimY_nx, waveSimY_nz)) / (2.0 * _LD_Params[_LD_SliceIndex].x);
		float2 dispXZ = _HorizDisplace * dydx / wavevector;

		const float maxDisp = _LD_Params[_LD_SliceIndex].x * _DisplaceClamp;
		dispXZ = clamp(dispXZ, -maxDisp, maxDisp);

		result.xz += dispXZ;
	}
#endif // _DYNAMIC_WAVE_SIM_

	SetValueAnimatedWavesCompute(uint3(id.xy, _LD_SliceIndex), half4(result, sss));
}


[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, 1)] void ShapeCombine(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, 1)] void ShapeCombine_DISABLE_COMBINE(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, 1)] void ShapeCombine_FLOW_ON(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, 1)] void ShapeCombine_FLOW_ON_DISABLE_COMBINE(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, 1)] void ShapeCombine_DYNAMIC_WAVE_SIM_ON(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, 1)] void ShapeCombine_DYNAMIC_WAVE_SIM_ON_DISABLE_COMBINE(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, 1)] void ShapeCombine_FLOW_ON_DYNAMIC_WAVE_SIM_ON(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, 1)] void ShapeCombine_FLOW_ON_DYNAMIC_WAVE_SIM_ON_DISABLE_COMBINE(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
