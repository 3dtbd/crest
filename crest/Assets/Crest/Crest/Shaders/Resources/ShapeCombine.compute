// Crest Ocean System

// This file is subject to the MIT License as seen in the root of this folder structure (LICENSE)

// TODO(MRT): Find solution lack of compute shader variants with regards to both
// flow and the dynamic wave sim

// NOTE: The order of these kernels is extremely important. They are used to
// allow LodDataMgrAnimWaves to select the appropriate compute shader variant
// depending on whether we want to combine LODs or not.
// see https://forum.unity.com/threads/how-to-create-compute-shader-variants.453638/
#pragma kernel ShapeCombine _SHAPE_COMBINE
#pragma kernel ShapeCombine

// TODO(MRT): Get this to work
#include "../OceanLODDataShared.hlsl"

float _HorizDisplace;
float _DisplaceClamp;
float _CrestTime;

RWTexture2DArray<float4> Result;

void Flow(out float2 offsets, out float2 weights)
{
	const float period = 3.0 * _LD_Params_ThisLod().x;
	const float half_period = period / 2.0;
	offsets = fmod(float2(_CrestTime, _CrestTime + half_period), period);
	weights.x = offsets.x / half_period;
	if (weights.x > 1.0) weights.x = 2.0 - weights.x;
	weights.y = 1.0 - weights.x;
}

float3 UVSliceToID(in float3 i_uv)
{
	return float3((i_uv.xy * float2(256, 256)) - 0.5, i_uv.z);
}

void SampleDisplacementsCompute(in RWTexture2DArray<float4> i_dispSampler, in float3 i_uv_slice, in float i_wt, inout float3 io_worldPos)
{
	// TODO(MRT): Replace this hacky attempt at bilenear filtering once I have
	// an internet connection to research something more standard. If that isn't
	// possible, verify that this actually generates the values we want.
	//
	// NOTE: It seems we may have to roll our own bilinear filter:
	// https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sm5-object-rwtexture2d
	// However, we still should give this a anotehr pass to ensure it is as
	// optimal and as accurate as possible.
	float3 posCenter = UVSliceToID(i_uv_slice);
	float2 botLeft = posCenter + float2(-.5, -.5);
	float2 topLeft = posCenter + float2(-.5, .5);
	float2 topRite = posCenter + float2(.5, .5);
	float2 botRite = posCenter + float2(.5, -.5);
	float botLeftProp = (1 - topRite.x % 1. + 1 - topRite.y % 1.) * .25;
	float topLeftProp = (1 - topRite.x % 1. + topRite.y % 1.) * .25;
	float topRiteProp = (topRite.x % 1. + topRite.y % 1.) * .25;
	float botRiteProp = (topRite.x % 1. + 1 - topRite.y % 1.) * .25;
	// const half3 disp = i_dispSampler[UVSliceToID(i_uv_slice)].xyz;
	half3 disp = i_dispSampler[float3(botLeft, posCenter.z)].xyz * botLeftProp;
	disp += i_dispSampler[float3(topLeft, posCenter.z)].xyz * topLeftProp;
	disp += i_dispSampler[float3(topRite, posCenter.z)].xyz * topRiteProp;
	disp += i_dispSampler[float3(botRite, posCenter.z)].xyz * botRiteProp;
	io_worldPos += i_wt * disp;
}

[numthreads(8,8,1)]
void ShapeCombine (uint3 id : SV_DispatchThreadID)
{
	const float2 input_uv = IDtoUV(id.xy);

	const float2 worldPosXZ = UVToWorld_ThisFrame(input_uv);

	// sample the shape 1 texture at this world pos
	const float3 uv_nextLod = WorldToUV_NextLod(worldPosXZ);

	float3 uv_thisLod = ADD_SLICE_THIS_LOD_TO_UV(input_uv);

	float3 result = 0.0;
	// this lods waves
#if _FLOW_ON
	float2 flow = 0.0;
	SampleFlow(_LD_TexArray_Flow_PrevFrame, uv_thisLod, 1.0, flow);

	float2 offsets, weights;
	Flow(offsets, weights);

	float3 uv_thisLod_flow_0 = WorldToUV_ThisLod(worldPosXZ - offsets[0] * flow);
	float3 uv_thisLod_flow_1 = WorldToUV_ThisLod(worldPosXZ - offsets[1] * flow);
	SampleDisplacements(_LD_TexArray_WaveBuffer_ThisFrame, uv_thisLod_flow_0, weights[0], result);
	SampleDisplacements(_LD_TexArray_WaveBuffer_ThisFrame, uv_thisLod_flow_1, weights[1], result);
#else
	SampleDisplacements(_LD_TexArray_WaveBuffer_ThisFrame, ADD_SLICE_THIS_LOD_TO_UV(uv_thisLod), 1.0, result);
#endif

// C# Script determines whether this enabled or not by selecting appropriate
// kernel for each LOD.
#if _SHAPE_COMBINE
	SampleDisplacementsCompute(Result, uv_nextLod, 1.0, result);
#endif

#if _DYNAMIC_WAVE_SIM_ON
	{
		// convert dynamic wave sim to displacements

		half waveSimY = SampleLod(_LD_TexArray_DynamicWaves_ThisFrame, uv_thisLod).x;
		result.y += waveSimY;

		const float2 invRes = float2(_LD_Params_PrevFrame[_LD_SLICE_Index_ThisLod].w, 0.0);
		const half waveSimY_px = SampleLod(_LD_TexArray_DynamicWaves_ThisFrame, uv_thisLod + float3(invRes.xy, 0)).x;
		const half waveSimY_nx = SampleLod(_LD_TexArray_DynamicWaves_ThisFrame, uv_thisLod - float3(invRes.xy, 0)).x;
		const half waveSimY_pz = SampleLod(_LD_TexArray_DynamicWaves_ThisFrame, uv_thisLod + float3(invRes.yx, 0)).x;
		const half waveSimY_nz = SampleLod(_LD_TexArray_DynamicWaves_ThisFrame, uv_thisLod - float3(invRes.yx, 0)).x;
		// compute displacement from gradient of water surface - discussed in issue #18 and then in issue #47

		// For gerstner waves, horiz displacement is proportional to derivative of vertical displacement multiplied by the wavelength
		const float wavelength_mid = 2.0 * _LD_Params_PrevFrame[_LD_SLICE_Index_ThisLod].x * 1.5;
		const float wavevector = 2.0 * 3.14159 / wavelength_mid;
		const float2 dydx = (float2(waveSimY_px, waveSimY_pz) - float2(waveSimY_nx, waveSimY_nz)) / (2.0 * _LD_Params_PrevFrame[_LD_SLICE_Index_ThisLod].x);
		float2 dispXZ = _HorizDisplace * dydx / wavevector;

		const float maxDisp = _LD_Params_PrevFrame[_LD_SLICE_Index_ThisLod].x * _DisplaceClamp;
		dispXZ = clamp(dispXZ, -maxDisp, maxDisp);

		result.xz += dispXZ;
	}
#endif // _DYNAMIC_WAVE_SIM_

	Result[uint3(id.xy, _LD_SLICE_Index_ThisLod)] = half4(result, 1.0);
}
