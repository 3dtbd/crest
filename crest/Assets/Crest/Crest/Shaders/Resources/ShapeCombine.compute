// Crest Ocean System

// This file is subject to the MIT License as seen in the root of this folder structure (LICENSE)

#pragma kernel ShapeCombine
#pragma kernel ShapeCombine_DISABLE_COMBINE _DISABLE_COMBINE
#pragma kernel ShapeCombine_FLOW_ON _FLOW_ON
#pragma kernel ShapeCombine_FLOW_ON_DISABLE_COMBINE _FLOW_ON _DISABLE_COMBINE
#pragma kernel ShapeCombine_DYNAMIC_WAVE_SIM_ON _DYNAMIC_WAVE_SIM_ON
#pragma kernel ShapeCombine_DYNAMIC_WAVE_SIM_ON_DISABLE_COMBINE _DYNAMIC_WAVE_SIM_ON _DISABLE_COMBINE
#pragma kernel ShapeCombine_FLOW_ON_DYNAMIC_WAVE_SIM_ON _FLOW_ON _DYNAMIC_WAVE_SIM_ON
#pragma kernel ShapeCombine_FLOW_ON_DYNAMIC_WAVE_SIM_ON_DISABLE_COMBINE _FLOW_ON _DYNAMIC_WAVE_SIM_ON _DISABLE_COMBINE

#include "../OceanLODData.hlsl"

float _HorizDisplace;
float _DisplaceClamp;
float _CrestTime;

RWTexture2DArray<float4> _LD_TexArray_AnimatedWaves_Compute;

void Flow(out float2 offsets, out float2 weights)
{
	const float period = 3.0 * _LD_Params[_LD_SliceIndex].x;
	const float half_period = period / 2.0;
	offsets = fmod(float2(_CrestTime, _CrestTime + half_period), period);
	weights.x = offsets.x / half_period;
	if (weights.x > 1.0) weights.x = 2.0 - weights.x;
	weights.y = 1.0 - weights.x;
}

void SampleDisplacementsCompute(in RWTexture2DArray<float4> i_dispSampler, in float3 i_uv_slice, in float i_wt, inout float3 io_worldPos)
{
	// NOTE: We have to roll our own bilinear filter in Compute shaders when
	// reading from a RWTexture. The documentation below explains how SRV
	// and UAV mappings of the same texture cannot exist at the same time.
	// https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sm5-object-rwtexture2d

	// TODO(MRT): Give this code another pass to ensure it is as
	// optimal and as accurate as possible.
	float2 texCoordCenter = UVToID(i_uv_slice.xy);
	// Calculate the locations of the 4 pixels from which we will be sampling
	float2 bottomLeftPixelPosition = texCoordCenter + float2(-.5, -.5);
	float2 topLeftPixelPosition = texCoordCenter + float2(-.5, .5);
	float2 topRightPixelPosition = texCoordCenter + float2(.5, .5);
	float2 bottomRightPixelPosition = texCoordCenter + float2(.5, -.5);

	// Calculate how much to weight the contribution of each pixel when we sample
	// it.
	float bottomLeftPixelPositionProportion = (1 - frac(topRightPixelPosition.x) + 1 - frac(topRightPixelPosition.y)) * .25;
	float topLeftPixelPositionProportion = (1 - frac(topRightPixelPosition.x) + frac(topRightPixelPosition.y)) * .25;
	float topRightPixelPositionProportion = (frac(topRightPixelPosition.x) + frac(topRightPixelPosition.y)) * .25;
	float bottomRightPixelPositionProportion = (frac(topRightPixelPosition.x) + 1 - frac(topRightPixelPosition.y)) * .25;

	// Sample each pixel and add to final result.
	half3 disp = i_dispSampler[float3(bottomLeftPixelPosition, i_uv_slice.z)].xyz * bottomLeftPixelPositionProportion;
	disp += i_dispSampler[float3(topLeftPixelPosition, i_uv_slice.z)].xyz * topLeftPixelPositionProportion;
	disp += i_dispSampler[float3(topRightPixelPosition, i_uv_slice.z)].xyz * topRightPixelPositionProportion;
	disp += i_dispSampler[float3(bottomRightPixelPosition, i_uv_slice.z)].xyz * bottomRightPixelPositionProportion;
	io_worldPos += i_wt * disp;
}

void ShapeCombineBase (uint3 id)
{
	const float2 input_uv = IDtoUV(id.xy);

	const float2 worldPosXZ = UVToWorld(input_uv);

	// sample the shape 1 texture at this world pos
	const float3 uv_nextLod = WorldToUV_NextLod(worldPosXZ);

	float3 uv_thisLod = float3(input_uv, _LD_SliceIndex);

	float3 result = 0.0;
	// this lods waves
#if _FLOW_ON
	float2 flow = 0.0;
	SampleFlow(_LD_TexArray_Flow, uv_thisLod, 1.0, flow);

	float2 offsets, weights;
	Flow(offsets, weights);

	float3 uv_thisLod_flow_0 = WorldToUV(worldPosXZ - offsets[0] * flow);
	float3 uv_thisLod_flow_1 = WorldToUV(worldPosXZ - offsets[1] * flow);
	SampleDisplacements(_LD_TexArray_WaveBuffer, uv_thisLod_flow_0, weights[0], result);
	SampleDisplacements(_LD_TexArray_WaveBuffer, uv_thisLod_flow_1, weights[1], result);
#else
	SampleDisplacements(_LD_TexArray_WaveBuffer, uv_thisLod, 1.0, result);
#endif

// C# Script determines whether this enabled or not by selecting appropriate
// kernel for each LOD.
#if !_DISABLE_COMBINE
	SampleDisplacementsCompute(_LD_TexArray_AnimatedWaves_Compute, uv_nextLod, 1.0, result);
#endif

#if _DYNAMIC_WAVE_SIM_ON
	{
		// convert dynamic wave sim to displacements

		half waveSimY = SampleLod(_LD_TexArray_DynamicWaves, uv_thisLod).x;
		result.y += waveSimY;

		const float2 invRes = float2(_LD_Params[_LD_SliceIndex].w, 0.0);
		const half waveSimY_px = SampleLod(_LD_TexArray_DynamicWaves, uv_thisLod + float3(invRes.xy, 0)).x;
		const half waveSimY_nx = SampleLod(_LD_TexArray_DynamicWaves, uv_thisLod - float3(invRes.xy, 0)).x;
		const half waveSimY_pz = SampleLod(_LD_TexArray_DynamicWaves, uv_thisLod + float3(invRes.yx, 0)).x;
		const half waveSimY_nz = SampleLod(_LD_TexArray_DynamicWaves, uv_thisLod - float3(invRes.yx, 0)).x;
		// compute displacement from gradient of water surface - discussed in issue #18 and then in issue #47

		// For gerstner waves, horiz displacement is proportional to derivative of vertical displacement multiplied by the wavelength
		const float wavelength_mid = 2.0 * _LD_Params[_LD_SliceIndex].x * 1.5;
		const float wavevector = 2.0 * 3.14159 / wavelength_mid;
		const float2 dydx = (float2(waveSimY_px, waveSimY_pz) - float2(waveSimY_nx, waveSimY_nz)) / (2.0 * _LD_Params[_LD_SliceIndex].x);
		float2 dispXZ = _HorizDisplace * dydx / wavevector;

		const float maxDisp = _LD_Params[_LD_SliceIndex].x * _DisplaceClamp;
		dispXZ = clamp(dispXZ, -maxDisp, maxDisp);

		result.xz += dispXZ;
	}
#endif // _DYNAMIC_WAVE_SIM_

	_LD_TexArray_AnimatedWaves_Compute[uint3(id.xy, _LD_SliceIndex)] = half4(result, 1.0);
}


[numthreads(THREAD_GROUP_SIZE_X,THREAD_GROUP_SIZE_Y,1)] void ShapeCombine(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
[numthreads(THREAD_GROUP_SIZE_X,THREAD_GROUP_SIZE_Y,1)] void ShapeCombine_DISABLE_COMBINE(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
[numthreads(THREAD_GROUP_SIZE_X,THREAD_GROUP_SIZE_Y,1)] void ShapeCombine_FLOW_ON(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
[numthreads(THREAD_GROUP_SIZE_X,THREAD_GROUP_SIZE_Y,1)] void ShapeCombine_FLOW_ON_DISABLE_COMBINE(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
[numthreads(THREAD_GROUP_SIZE_X,THREAD_GROUP_SIZE_Y,1)] void ShapeCombine_DYNAMIC_WAVE_SIM_ON(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
[numthreads(THREAD_GROUP_SIZE_X,THREAD_GROUP_SIZE_Y,1)] void ShapeCombine_DYNAMIC_WAVE_SIM_ON_DISABLE_COMBINE(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
[numthreads(THREAD_GROUP_SIZE_X,THREAD_GROUP_SIZE_Y,1)] void ShapeCombine_FLOW_ON_DYNAMIC_WAVE_SIM_ON(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
[numthreads(THREAD_GROUP_SIZE_X,THREAD_GROUP_SIZE_Y,1)] void ShapeCombine_FLOW_ON_DYNAMIC_WAVE_SIM_ON_DISABLE_COMBINE(uint3 id : SV_DispatchThreadID) { ShapeCombineBase(id); }
