// Crest Ocean System

// This file is subject to the MIT License as seen in the root of this folder structure (LICENSE)

#pragma kernel UpdateFoam

#pragma enable_d3d11_debug_symbols

#include "../OceanLODDataShared.hlsl"

float _FoamFadeRate;
float _WaveFoamStrength;
float _WaveFoamCoverage;
float _ShorelineFoamMaxDepth;
float _ShorelineFoamStrength;
float _SimDeltaTime;
float _SimDeltaTimePrev;
float _LODChange;

// TODO(MRT): Refactor OceanLODDataShared so that this code is actually shareable.
float2 UVToWorld_ThisFrameTest(in float2 i_uv, in float sliceIndex) { return LD_UVToWorld(i_uv, _LD_Pos_Scale_ThisFrame[sliceIndex].xy, _LD_Params_ThisFrame[sliceIndex].y, _LD_Params_ThisFrame[sliceIndex].x); }

float3 WorldToUV_ThisFrameTest(in float2 i_samplePos, in float sliceIndex) {
	const float2 result = LD_WorldToUV(
		i_samplePos,
		_LD_Pos_Scale_ThisFrame[sliceIndex].xy,
		_LD_Params_ThisFrame[sliceIndex].y,
		_LD_Params_ThisFrame[sliceIndex].x
	);
	return float3(result, sliceIndex);
}

float3 WorldToUV_PrevFrameTest(in float2 i_samplePos, in float sliceIndexPrevFrame) {
	const float2 result = LD_WorldToUV(
		i_samplePos,
		_LD_Pos_Scale_PrevFrame[sliceIndexPrevFrame].xy,
		_LD_Params_PrevFrame[sliceIndexPrevFrame].y,
		_LD_Params_PrevFrame[sliceIndexPrevFrame].x
	);
	return float3(result, sliceIndexPrevFrame);
}

RWTexture2DArray<float> _LD_TexArray_Target;

[numthreads(8,8,1)]
void UpdateFoam(uint3 id : SV_DispatchThreadID)
{
	// lod data 1 is current frame, compute world pos from quad uv
	const float sliceIndex = id.z;
	const float sliceIndexPrevFrame = id.z + _LODChange;
	const float2 input_uv = IDtoUV(id.xy);
	const float2 worldPosXZ = UVToWorld_ThisFrameTest(input_uv, sliceIndex);
	const float3 uv_slice = float3(input_uv, id.z);
	const float3 uv_slice_prevFrame = WorldToUV_PrevFrameTest(worldPosXZ, sliceIndexPrevFrame);
	// #if _FLOW_ON
	half3 velocity = half3(_LD_TexArray_Flow_ThisFrame.SampleLevel(LODData_linear_clamp_sampler, uv_slice, 0).xy, 0.0);
	half foam = _LD_TexArray_Foam_PrevFrame.SampleLevel(LODData_linear_clamp_sampler, uv_slice_prevFrame
		- ((_SimDeltaTime * _LD_Params_PrevFrame[sliceIndexPrevFrame].w) * velocity), 0
		).x;
	// #else
	// // sampler will clamp the uv_slice currently
	// half foam = tex2Dlod(_LD_TexArray_Foam_PrevFrame, uv_slice_prevFrame).x;
	// #endif

	half2 r = abs(uv_slice_prevFrame.xy - 0.5);

	float depth;
	{
		float width; float height;
		_LD_TexArray_Foam_PrevFrame.GetDimensions(width, height, depth);
	}
	if (
		(sliceIndexPrevFrame < 0) || (sliceIndexPrevFrame > depth) ||
		(max(r.x, r.y) > 0.5 - _LD_Params_PrevFrame[sliceIndexPrevFrame].w)
	) {
		// no border wrap mode for RTs in unity it seems, so make any off-texture reads 0 manually
		foam = 0.0;
	}

	// fade
	foam *= max(0.0, 1.0 - _FoamFadeRate * _SimDeltaTime);

	// sample displacement texture and generate foam from it
	const float3 dd = float3(_LD_Params_ThisFrame[sliceIndex].w, 0.0, _LD_Params_ThisFrame[sliceIndex].x);
	half3 s = SampleLod(_LD_TexArray_AnimatedWaves_ThisFrame, uv_slice).xyz;
	half3 sx = SampleLodLevel(_LD_TexArray_AnimatedWaves_ThisFrame, uv_slice + float3(dd.xy, 0), dd.y).xyz;
	half3 sz = SampleLodLevel(_LD_TexArray_AnimatedWaves_ThisFrame, uv_slice + float3(dd.yx, 0), dd.y).xyz;
	float3 disp = s.xyz;
	float3 disp_x = dd.zyy + sx.xyz;
	float3 disp_z = dd.yyz + sz.xyz;
	// The determinant of the displacement Jacobian is a good measure for turbulence:
	// > 1: Stretch
	// < 1: Squash
	// < 0: Overlap
	float4 du = float4(disp_x.xz, disp_z.xz) - disp.xzxz;
	float det = (du.x * du.w - du.y * du.z) / (_LD_Params_ThisFrame[sliceIndex].x * _LD_Params_ThisFrame[sliceIndex].x);
	foam += 5.0 * _SimDeltaTime * _WaveFoamStrength * saturate(_WaveFoamCoverage - det);

	// add foam in shallow water. use the displaced position to ensure we add foam where world objects are.
	float3 uv_slice_thisFrame_displaced = WorldToUV_ThisFrameTest(worldPosXZ + disp.xz, sliceIndex);
	float signedOceanDepth = SampleLodLevel(_LD_TexArray_SeaFloorDepth_ThisFrame, uv_slice_thisFrame_displaced, 1).x + disp.y;
	foam += _ShorelineFoamStrength * _SimDeltaTime * saturate(1.0 - signedOceanDepth / _ShorelineFoamMaxDepth);

	_LD_TexArray_Target[id] = foam;
}
